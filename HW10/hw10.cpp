// CSE240 Spring 2022 HW10
// Suvan Kumar
// VS

// READ BEFORE YOU START:
// You are given a partially completed program that creates a list of players.
// Each player has name, a set of stats, and an archetype (Warrior, Wizard, or Rogue).
// This information is stored as an object of Player class. The class is defined in player.h
// The classes Warrior, Wizard, and Rogue are child classes of the Player class.
// When adding a new player, these child classes are used to make the player node of the list.
// So each node in the list is actually an object of Warrior, Wizard, or Rogue class.

// To begin, you should trace through the given code and understand how it works.
// Please read the instructions above each required function and follow the directions carefully.
// Do not modify given code.

// You can assume that all input is valid:
// Valid name:	String containing alphabetical letters
// Valid number: a positive integer

#include <iostream>
#include <fstream>
#include <string>
#include "Container.h"
#include "player.h"
#include "warrior.h"
#include "wizard.h"
#include "rogue.h"

using namespace std;

// functions already implemented:
void executeAction(char c);
Player* searchPlayer(string nameInput);

// functions that need implementation:
void updateLevel(Player* player, int level);						//forward declaration
void addPlayer(string nameInput, int levelInput, playerType type);	// 5 points
void displayList();							// 5 points
void save(string fileName);						// 5 points
void load(string fileName);						// 5 points

Container* list = NULL;				// global list

int main()
{
	char c = 'i';				// initialized to a dummy value

  // During first execution, there will be no list.txt in source directory. list.txt is generated by save() while exiting the program.
	load("list.txt");
	do {
		cout << "\nCSE240 HW10\n";
		cout << "Please enter your selection:\n";
		cout << "\t a: add a new player\n";
		cout << "\t d: display player list\n";
		cout << "\t c: change level of a player\n";
		cout << "\t q: quit\n";
		cin >> c;
		cin.ignore();
		executeAction(c);
	} while (c != 'q');

	save("list.txt");

	list = NULL;

	return 0;
}

// Ask for details from user for the given selection and perform that action
// Read the function case by case
void executeAction(char c)
{
	string nameInput;
	int levelInput;
	int typeInput = 3;
	playerType type;
	Player* playerResult = NULL;

	switch (c)
	{
	case 'a':	// add player
			// input player details from user
		cout << endl << "Enter player name: ";
		getline(cin, nameInput);
		cout << "Enter new player level: ";
		cin >> levelInput;
		cin.ignore();

		while (!(typeInput == 0 || typeInput == 1 || typeInput == 2))
		{
			cout << "Enter player archetype: " << endl;
			cout << "0. Warrior " << endl;
			cout << "1. Wizard" << endl;
			cout << "2. Rogue"<< endl;
			cin >> typeInput;
			cin.ignore();
		}
		type = (playerType)typeInput;

		// searchPlayer() will return the player object if found, else returns NULL
		playerResult = searchPlayer(nameInput);
		if (playerResult == NULL)
		{
			addPlayer(nameInput, levelInput, type);
			cout << endl << "Player added to list!" << endl << endl;
		}
		else
			cout << endl << "Player already present in the list!" << endl << endl;

		break;

	case 'd':		// display the list
		cout << endl;
		displayList();
		break;

	case 'c':		// change level
		cout << endl << "Enter player name: ";
		getline(cin, nameInput);
		// searchPlayer() will return the player node if found, else returns NULL
		playerResult = searchPlayer(nameInput);
		if (playerResult == NULL)
		{
			cout << endl << "Player not in list!" << endl << endl;
		}
		else
		{
			// if player exists in the list, then ask user for a new level
			cout << endl << "Enter new level: ";
			cin >> levelInput;
			cin.ignore();

			// Q3-c: Call changeLevel() here   (1 point)
			// 'playerResult' contains the player whose 'level' is to be changed.
			// 'levelInput' contains the new level of the player.
			// Call the function with appropriate arguments.
			updateLevel(playerResult, levelInput);												//function call
			cout << endl << "Level changed!" << endl << endl;
		}
		break;

	case 'q':		// quit
		break;

	default: cout << c << " is invalid input!\n";
	}

}

// No implementation needed here, however it may be helpful to review this function
Player* searchPlayer(string nameInput)
{

	Container* tempList = list;			// work on a copy of 'list'

	while (tempList != NULL)			// parse till end of list
	{
		if (tempList->player->getName() == nameInput)
		{
			return tempList->player;	// return the player if found
		}

		tempList = tempList->next;		// parse the list
	}

	return NULL;					// return NULL if player not found in list
}

// Q3-b: Define Friend Function updateLevel()  (3 points)
// Define the function updateLevel()that is declared in player.h file.
// This function sets the new 'level' of the player. The player object and new level is to be passed as function arguments.
// Use 'd' display option after using 'c' option to verify.
// You will need to implement addPlayer() and displayList() before you test this function.
// Updating a player's level will update their stats. This scaling matches the same scaling as the constructor in player.cpp.


void updateLevel(Player *player, int newLevel) {
	//update level
	player->level = newLevel;
	//update other attributes accordingly if archetype is warrior
	if (player->archetype == warrior) {
		player->health = newLevel * 100;
		player->mana = newLevel * 10;
		player->armor = newLevel * 50;
		player->magicResist = newLevel * 25;
		player->attack = newLevel * 50;
		player->magicAttack = newLevel * 10;
	}
	//update other attributes accordingly if archetype is wizard
	else if (player->archetype == wizard) {
		player->health = newLevel * 25;
		player->mana = newLevel * 100;
		player->armor = newLevel * 10;
		player->magicResist = newLevel * 50;
		player->attack = newLevel * 10;
		player->magicAttack = newLevel * 100;
	}
	//update other attributes accordingly if archetype is rogue
	else {
		player->health = newLevel * 50;
		player->mana = newLevel * 25;
		player->armor = newLevel * 25;
		player->magicResist = newLevel * 10;
		player->attack = newLevel * 100; 
		player->magicAttack = newLevel * 50;
	}
}


// Q4: addPlayer  (5 points)
// This function is used to add a new player to the global linked list 'list'. Add the new player to tail of the list.
// playerType 'type' can be warrior, wizard, or rogue. You will need to use the function argument �type� to determine which constructor to use to create new player node.
// For example, if the user enters type as 'rogue', then you need to use the Rogue class and constructor to create new player node and add it to the list.
// NOTE: In executeAction(), searchPlayer() is called before this function. Therefore no need to check here if the player exists in the list.
//       See how this fucntion is called in case 'a' of executeAction()
void addPlayer(string nameInput, int levelInput, playerType type)
{
	Container* tempList = list;				// work on a copy of 'list'
	// Write the code below
	Container* newPlayer1 = new Container();										//container to be added to tail of list
	Player* newPlayer;																//player to be part of container newPlayer1
	//check type and call the respective constructor
	if (type == rogue) {
		newPlayer = new Rogue(nameInput, levelInput, type);
	}
	else if (type == warrior) {
		newPlayer = new Warrior(nameInput, levelInput, type);
	}
	else {
		newPlayer = new Wizard(nameInput, levelInput, type);
	}
	//add player to container and set next to NULL
	newPlayer1->player = newPlayer;
	newPlayer1->next = NULL;
	//check if list is empty
	if (tempList == NULL) {
		list = newPlayer1;
	}
	//otherwise, iterate to the tail
	else {
		while (tempList->next != NULL) {
			tempList = tempList->next;
		}
		tempList->next = newPlayer1;
	}
	
}

// Q5: displayList	(5 points)
// This function displays the list of players and their details (name, level, archetype)
// Parse the list and use the class member function to display the player info.
// See expected output in the question file.
// Separate each output by an endl.
void displayList()
{
	Container* tempList = list;			// work on a copy of 'list'
	// write the code below
	//check if list is empty and display accordingly
	if (tempList == 0) {
		cout << endl << "List is empty!" << endl;
	}
	//if list is not empty, iterate through list and call the displayPlayer class member function for each player
	else {
		while(tempList != 0) {
			tempList->player->displayPlayer();
			cout << endl;										//new line
			tempList = tempList->next;
		}
	}
}

// Q6: save  (5 points)
// Save the linked list of players to a file list.txt using ofstream.
// You will need to save the number of players in linked list. That will help in load() when reading the file.
// You must store in the following format:
// <no. of players>
// <Player1 name>
// <Player1 level>
// <Player1 archetype>
// <Player2 name>
// <Player2 level>
// <Player2 archetype>
// and so on..
// You may store the list in another format if you wish. You need to read the file in load () the same way that it is saved in save().
// This function is called when exiting the program (end of main() ).
// Hint: You should cast the enum �playerType� to an int before writing it to the file.
void save(string fileName)
{
	ofstream myFile;
	Container* tempList = list;									//copy of list used to iterate through and add to file
	Container* countList = list;								//copy of list used to find the count
	int count;

	//iterate through copy of list to get count
	while (countList != NULL) {													
		countList = countList->next;
		count++;
	}

	myFile.open(fileName);													//open file
	if(myFile.is_open()) {													//check if file is open
		myFile << count << endl;											//add count
		while (tempList != NULL) {											//iterate while tempList has not reached the end
			myFile << tempList->player->getName() << endl;					//add name
			myFile << tempList->player->getLevel() << endl;					//add level
			myFile << tempList->player->getPlayerType() << endl;			//add archetype
			tempList = tempList->next;										//move to next container in tempList
		}
		myFile.close();														//close file
	}
}

// Q7: load (5 points)
// Load the linked list of players from the file using ifstream.
// You will need to create the linked list in the same order that is was saved to the file in save().
// First, read the number of players saved in the file.
// Then, for every player you will need to create a new Player node depending on player archetype. Add the player to the tail of the list. 
// Hint: The enum 'playerType' will need to be cast back to 'playerType' when making the player node.
// This function is called at the beginning of main().
void load(string fileName)
{
	// Write the code below
	ifstream myFile;

	myFile.open(fileName);												//open file

	if (myFile.is_open()) {												//check if file is open
		//variable declarations
		string count1;												
		string name, level1, type1;
		int count, level, type;

		getline(myFile, count1);										//get # of players in file
		count = stoi(count1);											//convert from string to int

		for (int i = 0; i < count; i++) {								//for loop with the constraint as num of players in file
			Player* player;					
			Container* newPlayer = new Container();
			Container* tempList = list;
			//get name, level, and type of player
			getline(myFile, name);
			getline(myFile, level1);
			getline(myFile, type1);
			//convert level and type to int
			level = stoi(level1);
			type = stoi(type1);

			//warrior
			if (type == 0) {
				player = new Warrior(name, level, warrior);
			}
			//wizard
			else if (type == 1) {
				player = new Wizard(name, level, wizard);
			}
			//rogue
			else {
				player = new Rogue(name, level, rogue);
			}
			//add player to container
			newPlayer->player = player;
			newPlayer->next = NULL;
			//if list is empty
			if (tempList == NULL) {
				list = newPlayer;
			}
			else {
				//iterate through list until the tail
				while (tempList->next != NULL) {
					tempList = tempList->next;
				}
				tempList->next = newPlayer;
			}
		}
		myFile.close();												//close file
	}

}




